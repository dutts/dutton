---
layout: post
title: Playing with Predicate
date: 2013-03-16 07:07:13.000000000 +00:00
type: post
published: true
status: publish
categories:
- C#
- Software Development
tags:
- .NET
- c#
- linq
- params
- predicate
- programming
- where
meta:
  _edit_last: '2'
  _wpas_done_all: '1'
  _wpas_skip_2785187: '1'
  _wpas_skip_2785197: '1'
  _wpas_skip_3579159: '1'
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1461155298;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:518;}i:1;a:1:{s:2:"id";i:1732;}i:2;a:1:{s:2:"id";i:558;}}}}
author:
  login: admin
  email: richard@dutton.me.uk
  display_name: richard
  first_name: ''
  last_name: ''
---
<p>I came across a problem during recent round of refactoring. Here's a contrived simiIar example.</p>
<p>I have an IEnumerable, MyThings contains a property of type Enum called MyThingType. Scattered around my class I found I had quite a bit of duplicated code consisting of a Linq Where statement to filter the IEnumerable based on a specific values of MyThingType and then perform some additional actions on the result.</p>
<pre name="code" class="c-sharp">var filtereredThings = MyThingsList.Where(t =&gt; t.MyThingType == ThingType.ThingA);
// other stuff on filteredThings</pre>
<p>All good so far, I extracted the common code into a new private method call which returned my result and took the MyThingType as a parameter to filter on, the problem arose when my last Where statement filtered on&nbsp;<strong>two</strong> MyThingType values.</p>
<pre name="code" class="c-sharp">private IEnumerable FilterAndProcessThingType(IEnumerable data, ThingType filterType)
{
  var filtereredThings = MyThingsList.Where(t =&gt; t.MyThingType == filterType);
  // other stuff on filteredThings and return result
}</pre>
<p>I changed my method to take a params parameter for the filter so I can pass a variable number of MyThingType in, but how do I change my Linq?</p>
<pre name="code" class="c-sharp">private IEnumerable FilterAndProcessThingType(IEnumerable data, params ThingType[] filterType)
{
  var filtereredThings = MyThingsList.Where(t =&gt; t.MyThingType == ???);
  // other stuff on filteredThings and return result
}</pre>
<p>This is where Predicate comes in; a Predicate is a function which returns true or false. This means I can dynamically create one to do my MyThingType check and put it in my Where's Lambda expression.</p>
<pre name="code" class="c-sharp">private IEnumerable FilterAndProcessThingType(IEnumerable data, params ThingType[] typeFilter)
{
  var thingTypeMatcher = new Predicate&lt;tuple&lt;thingtype, thingtype[]=""&gt;&gt;(t =&gt;
  {
    var thingType = t.Item1;
    var thingTypeArray = t.Item2;
    return thingTypeArray.Aggregate(false,(current, type) =&gt; current | thingType == type);
  });
  var filtereredThings = MyThingsList.Where(t =&gt; thingTypeMatcher(new Tuple&lt;thingtype, thingtype[]=""&gt;(t.MyThingType, typeFilter));
  // other stuff on filteredThings and return result
}</pre>
<p>And that's it, now I can pass a variable number of types to match into my common code.</p>
